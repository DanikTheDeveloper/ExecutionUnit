library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

architecture CSA of Adder is
    signal P, G : std_logic_vector(N-1 downto 0); -- A vector of N-1 bits for Propagate and Generate signals.
    signal C    : std_logic_vector(N downto 0);   -- A vector of N bits for cin and cout.
    constant BLOCK_SIZE : integer := 4; -- Size of each skipping carry block

begin
    -- Initial input carry bit
    C(0) <= Cin;

    -- Generating N-1 Propagate and Generate signals
    gen_pg: for i in 0 to N-1 generate
        begin
            P(i) <= A(i) xor B(i);  -- Propagate signals
            G(i) <= A(i) and B(i);  -- Generate signals
        end generate;

    -- Calculating the carry bits for each block
    process(Cin, A, B)
    variable block_num : integer;
    begin
        -- Initial input carry bit
        C(0) <= Cin;

        for block_num in 0 to (N/BLOCK_SIZE)-1 loop
            -- Calculating the internal carry for the first bit of each block
            C(block_num*BLOCK_SIZE + 1) <= G(block_num*BLOCK_SIZE) or (P(block_num*BLOCK_SIZE) and C(block_num*BLOCK_SIZE));
            
            -- Generating the Carry signals
            for i in block_num*BLOCK_SIZE + 1 to (block_num+1)*BLOCK_SIZE-1 loop
                C(i+1) <= G(i) or (P(i) and C(i));
            end loop;

            -- Checking if carry can be skipped
            -- If all propagate signals =='1' we can skip the carry
            if (P(block_num*BLOCK_SIZE) = '1') and (P(block_num*BLOCK_SIZE + 1) = '1') and 
               (P(block_num*BLOCK_SIZE + 2) = '1') and (P(block_num*BLOCK_SIZE + 3) = '1') then
                C((block_num+1)*BLOCK_SIZE) <= C(block_num*BLOCK_SIZE);
            end if;
        end loop;
    end process;

    -- Generating the Sum signals
    gen_sum: for i in 0 to N-1 generate
        begin
            Sum(i) <= P(i) xor C(i);
        end generate;

    -- Connecting final Cout to Adder Cout
    Cout <= C(N);

    -- Overflow occurs when we have a carry out for Nth bit
    Ovfl <= C(N) xor C(N-1);
end architecture CSA;

